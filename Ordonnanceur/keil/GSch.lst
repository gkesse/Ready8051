C51 COMPILER V8.12   GSCH                                                                  10/03/2017 20:02:27 PAGE 1   


C51 COMPILER V8.12, COMPILATION OF MODULE GSCH
OBJECT MODULE PLACED IN .\GSch.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\..\lib\GSch.c BROWSE INCDIR(..\..\lib) DEBUG OBJECTEXTEND PRINT(.\GSch.l
                    -st) OBJECT(.\GSch.obj)

line level    source

   1          //===============================================
   2          #include "GSch.h"
   3          //===============================================
   4          #define PRELOAD01 (65536 - ((OSC_FREQ * 1) / (OSC_PER_INST * 1000))) // ms
   5          #define PRELOAD01H (PRELOAD01 / 256)
   6          #define PRELOAD01L (PRELOAD01 % 256)
   7          //===============================================
   8          #define SCH_MAX_TASKS (2)
   9          //===============================================
  10          GTask Sch_Tasks_Map[SCH_MAX_TASKS];
  11          //===============================================
  12          void GSch_Go_To_Sleep();
  13          void GSch_Delete_Task(const uchar index);
  14          //===============================================
  15          void GSch_Init() {
  16   1          uchar index;
  17   1          for(index = 0; index < SCH_MAX_TASKS; index++) {
  18   2              GSch_Delete_Task(index);
  19   2          }
  20   1          T2CON = 0x00; 
  21   1          TH2 = PRELOAD01H; 
  22   1          RCAP2H = PRELOAD01H; 
  23   1          TL2 = PRELOAD01L; 
  24   1          RCAP2L = PRELOAD01L;
  25   1          ET2 = 1;
  26   1          TR2 = 1;
  27   1      }
  28          //===============================================
  29          void GSch_Start() {
  30   1          EA = 1;
  31   1      }
  32          //===============================================
  33          void GSch_Go_To_Sleep() {
  34   1          PCON |= 0x01;
  35   1      }
  36          //===============================================
  37          void GSch_Dispatch_Tasks() {
  38   1          uchar index;
  39   1          for(index = 0; index < SCH_MAX_TASKS; index++) {
  40   2              if(Sch_Tasks_Map[index].runMe > 0) {
  41   3                  (*Sch_Tasks_Map[index].pTask)();
  42   3                  Sch_Tasks_Map[index].runMe -= 1;
  43   3                  if(Sch_Tasks_Map[index].period == 0) {
  44   4                      GSch_Delete_Task(index);
  45   4                  }
  46   3              }
  47   2          }
  48   1          GSch_Go_To_Sleep();
  49   1      }
  50          //===============================================
  51          void GSch_Add_Task(void (*pTask)(), const uint delay, const uint period) {
  52   1          uchar index = 0;
  53   1          while((Sch_Tasks_Map[index].pTask != 0) && (index < SCH_MAX_TASKS)) index++;
  54   1          if(index == SCH_MAX_TASKS) return;
C51 COMPILER V8.12   GSCH                                                                  10/03/2017 20:02:27 PAGE 2   

  55   1          Sch_Tasks_Map[index].pTask = pTask;
  56   1          Sch_Tasks_Map[index].delay = delay;
  57   1          Sch_Tasks_Map[index].period = period;
  58   1          Sch_Tasks_Map[index].runMe = 0;
  59   1      }
  60          //===============================================
  61          void GSch_Delete_Task(const uchar index) {
  62   1          Sch_Tasks_Map[index].pTask = 0x0000;
  63   1          Sch_Tasks_Map[index].delay = 0;
  64   1          Sch_Tasks_Map[index].period = 0;
  65   1          Sch_Tasks_Map[index].runMe = 0;
  66   1      }
  67          //===============================================
  68          #ifdef GSDCC /* SDCC C Compiler */
              void GSch_Update() __interrupt(INTERRUPT_TIMER_T2) 
              #else /* Keil µVision C Compiler */
  71          void GSch_Update() interrupt INTERRUPT_TIMER_T2 
  72          #endif
  73          {
  74   1          uchar index;
  75   1          TF2 = 0;
  76   1          for(index = 0; index < SCH_MAX_TASKS; index++) {
  77   2              if(Sch_Tasks_Map[index].pTask != 0) {
  78   3                  if(Sch_Tasks_Map[index].delay == 0) {
  79   4                      Sch_Tasks_Map[index].runMe += 1;
  80   4                      if(Sch_Tasks_Map[index].period != 0) {
  81   5                          Sch_Tasks_Map[index].delay = Sch_Tasks_Map[index].period;
  82   5                      }
  83   4                  }
  84   3                  else {
  85   4                      Sch_Tasks_Map[index].delay -= 1;
  86   4                  }
  87   3              }
  88   2          }
  89   1      }
  90          //===============================================


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    401    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
